% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/store_llm_result.R
\name{store_llm_result}
\alias{store_llm_result}
\title{Store LLM result in database}
\usage{
store_llm_result(
  parsed_result,
  conn = NULL,
  db_path = "llm_results.db",
  auto_close = is.null(conn)
)
}
\arguments{
\item{parsed_result}{List from parse_llm_result()}

\item{conn}{Database connection (optional, will create if NULL)}

\item{db_path}{Database file path for SQLite or config for unified connection (default: "llm_results.db")}

\item{auto_close}{Whether to close connection after operation (default: TRUE if conn is NULL)}
}
\value{
List with success status and optional error message
}
\description{
Simple storage function following Unix philosophy and tidyverse style.
Takes parsed result, stores it, returns success/failure.
Works transparently with both SQLite and PostgreSQL backends.
}
\examples{
\dontrun{
# Basic usage with parsed result
response <- call_llm("Analyze this narrative...", "System prompt")
parsed <- parse_llm_result(response, narrative_id = "case_123")

# Store the result
result <- store_llm_result(parsed)
if (result$success) {
  message("Result stored successfully")
} else {
  warning("Storage failed: ", result$error)
}

# Using existing connection for better performance
conn <- get_db_connection()
ensure_schema(conn)

result <- store_llm_result(parsed, conn = conn, auto_close = FALSE)
# ... store more results ...
close_db_connection(conn)

# Custom database file
store_llm_result(parsed, db_path = "experiment_results.db")
}
}
